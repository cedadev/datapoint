<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DataPoint’s Cloud Product Handler &mdash; CEDA DataPoint 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=01f34227"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DataPoint Objects" href="objects.html" />
    <link rel="prev" title="CEDA DataPoint - Basic Usage" href="usage.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            CEDA DataPoint
              <img src="_static/ceda.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Details:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="inspiration.html">Inspiration</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">How to Use DataPoint</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DataPoint's Cloud Product Handler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-datapointcloudproduct-class">The <code class="docutils literal notranslate"><span class="pre">DataPointCloudProduct</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#datapointcluster-objects"><code class="docutils literal notranslate"><span class="pre">DataPointCluster</span></code> objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cloud-formats">Cloud Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kerchunk-reference-format">1. Kerchunk Reference format</a></li>
<li class="toctree-l2"><a class="reference internal" href="#zarr-stores">2. Zarr stores</a></li>
<li class="toctree-l2"><a class="reference internal" href="#climate-forecast-aggregations-cfa">3. Climate Forecast Aggregations (CFA)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">DataPoint Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="mappers.html">Mappings for Non-CEDA STAC Catalogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">When to Use DataPoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="stac.html">STAC Catalogs Explained</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="core_client.html">Client and Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="core_item.html">STAC Items</a></li>
<li class="toctree-l1"><a class="reference internal" href="core_cloud.html">Clusters and Cloud Products</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixins.html">Mixins</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CEDA DataPoint</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">DataPoint’s Cloud Product Handler</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/cloud_formats.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="datapoint-s-cloud-product-handler">
<h1>DataPoint’s Cloud Product Handler<a class="headerlink" href="#datapoint-s-cloud-product-handler" title="Link to this heading"></a></h1>
<section id="the-datapointcloudproduct-class">
<h2>The <code class="docutils literal notranslate"><span class="pre">DataPointCloudProduct</span></code> class<a class="headerlink" href="#the-datapointcloudproduct-class" title="Link to this heading"></a></h2>
<p>For any users wanting to take advantage of the functionality within datapoint to configure and open datasets via STAC records, this operator is the object to use.
The <code class="docutils literal notranslate"><span class="pre">DataPointCloudProduct</span></code> operator can be instantiated for each conformant asset from one or more items. For a single item:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ceda_datapoint.core.cloud</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataPointCloudProduct</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ceda_datapoint.core.item</span><span class="w"> </span><span class="kn">import</span> <span class="n">identify_cloud_type</span>

<span class="n">products</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">asset</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">assets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
   <span class="n">cf</span> <span class="o">=</span> <span class="n">identify_cloud_type</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">asset</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">cf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">continue</span>
   <span class="n">products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
      <span class="n">DataPointCloudProduct</span><span class="p">(</span>
         <span class="n">asset</span><span class="p">,</span>   <span class="c1"># The asset obtained from pystac.Item</span>
         <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="c1"># ID of the asset (can be combined with the item ID)</span>
         <span class="n">cf</span><span class="o">=</span><span class="n">cf</span><span class="p">,</span>   <span class="c1"># Cloud format identified above.</span>
         <span class="n">meta</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;bbox&#39;</span><span class="p">:</span><span class="n">bounding_box</span><span class="p">},</span> <span class="c1"># See below.</span>
         <span class="n">properties</span><span class="o">=</span><span class="n">properties</span>       <span class="c1"># Properties of the parent item.</span>
      <span class="p">)</span>
   <span class="p">)</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">item</span></code> is a pystac object that can be obtained from the <code class="docutils literal notranslate"><span class="pre">pystac-client</span></code> or a similar pystac implementation.
The cloud format/type (see below) can be identifier using the function <code class="docutils literal notranslate"><span class="pre">identify_cloud_type</span></code> also imported from DataPoint.
This relies on either the <code class="docutils literal notranslate"><span class="pre">id</span></code> of the asset conforming to the labels that DataPoint expects (i.e <code class="docutils literal notranslate"><span class="pre">reference_file</span></code>) or the asset containing
a property called <code class="docutils literal notranslate"><span class="pre">cloud_format</span></code>. If the asset contains a the cloud format but under a different name, the <code class="docutils literal notranslate"><span class="pre">cflabel</span></code> can be adjusted accordingly.
If the cloud label is nested within the asset, a mapper can be supplied (see the section on Mappers).</p>
<p>We can then initialise a <code class="docutils literal notranslate"><span class="pre">DataPointCloudProduct</span></code> for this asset. There are additional kwargs that can be supplied but the important ones are highlighted above.
For the <code class="docutils literal notranslate"><span class="pre">meta</span></code> argument, a dictionary must be given which (at minimum) includes the bounding box (which is not typically part of the Item’s properties).
Other attributes of the item that apply to the asset can be passed using this mechanism. STAC properties (like STAC version) can be passed using the
<code class="docutils literal notranslate"><span class="pre">stac_attrs</span></code> kwarg if necessary.</p>
</section>
<section id="datapointcluster-objects">
<h2><code class="docutils literal notranslate"><span class="pre">DataPointCluster</span></code> objects<a class="headerlink" href="#datapointcluster-objects" title="Link to this heading"></a></h2>
<p>In the above example, a list of cloud products is generated for convenience. Instead, we could combine these into a <code class="docutils literal notranslate"><span class="pre">cluster</span></code> object which comes with some benefits
over just using a list:</p>
<blockquote>
<div><ul class="simple">
<li><p>String representation with metadata</p></li>
<li><p>Able to obtain a listing of metadata in each cloud product.</p></li>
<li><p>Help/Info methods available.</p></li>
<li><p>Able to open a dataset directly from the cluster.</p></li>
<li><p>Indexable, so can extract a product by ID or position.</p></li>
</ul>
</div></blockquote>
</section>
<section id="cloud-formats">
<h2>Cloud Formats<a class="headerlink" href="#cloud-formats" title="Link to this heading"></a></h2>
<p>From recent user surveys relating to the Climate Model Intercomparison Project (CMIP6)
datasets available via the CEDA Archive, some common issues and barriers to research relate to how to find and access the data itself.</p>
<p>Research is typically undertaken by either connecting to JASMIN using remote SSH to access data, or downloading
entire datasets to local institutions for data analysis. The download process can
take weeks for some datasets, and not all institutions are able to provide remote JASMIN access.
To give data users alternative ways of accessing data without requiring large downloads of data,
cloud-accessible methods of data aggregation must be explored.</p>
<p>Cloud optimisation typically involves breaking up the existing data structure into easy-to-manage data <code class="docutils literal notranslate"><span class="pre">chunks</span></code>
which can then be requested individually, so if a user would like to utilise only a specific subset of data,
they only need to access the relevant parts. The chunk structure therefore directly affects performance, and
special consideration must be given to the size and shapes of chunks diven the end use-case. For example, if all
users are likely to look at regions no smaller than a single country, your chunk sizes should be at least as small,
if not smaller. If the chunk structure is much larger than the area of interest, the user is forced to download a large
set of data, only to discard most of it to then access their small area.</p>
<p>There are generally two approaches with allowing individual chunk access to data:
- reformat: break them up into separate objects that can be individually requested.
- reference: provide a mechanism to get a specific byte range corresponding to that chunk from a larger object.</p>
<p>The most common formats for utilising these methods (for raster data) are Zarr and Kerchunk respectively.</p>
<img alt="Diagram of when to use specific optimised formats based on chunk structure." src="_images/ChunksPerFileDiagram.png" />
<p>The above diagram demonstrates when is appropriate to use both optimisation methods. Since the reference method does not involve
changing the original chunk structure, it is best to use when there is a high level of chunking already present,
which can easily be mapped. There are two competing formats to store the references, both used by Kerchunk, depending on how many
references your dataset will produce.</p>
<p>If the source files are not well chunked for the use case or have very few chunks in general, the best solution is reformatting
to a format like Zarr, which will allow the chunk structure to be altered.</p>
</section>
<section id="kerchunk-reference-format">
<h2>1. Kerchunk Reference format<a class="headerlink" href="#kerchunk-reference-format" title="Link to this heading"></a></h2>
<p>Kerchunk was developed by Martin Durant at Anaconda as a Python library for cloud-friendly access
to archival data by reference, an alternative to converting archival data into newer cloud-optimised formats.
There are specific similarities in syntax between Kerchunk and Zarr as there is a significant overlap
between the teams working on both. The key difference with Kerchunk is that the data is not converted
or transformed, instead a kerchunk reference file is created which acts as an interface to archived
NetCDF data. NetCDF files contain encoded data with embedded metadata, shown in Figure.
Byte-range requests are supported but without opening the file first, the locations of data
chunks are unknown. The Kerchunk process maps out all chunks within each file in a dataset and
creates a list of chunk locations and sizes, producing a JSON file which can then be used to make
range requests.</p>
<img alt="Diagram for accessing an archive via a Kerchunk reference file." src="_images/KerchunkDiagram.png" />
<p>Since Kerchunk files can be opened using Xarray the chunks can be loaded when
required rather than all at once, a process called Lazy Loading. This removes the requirement
of downloading an entire NetCDF file to determine which parts of the data are required. In
that way Kerchunk does part of the work of Zarr, but without the second step of physically
moving the data into separate containers. Any Kerchunk user can use HTTP GET requests to
retrieve specific byte-ranges of data served by NginX/Apache web-servers which are
then combined into a single Xarray dataset object.</p>
</section>
<section id="zarr-stores">
<h2>2. Zarr stores<a class="headerlink" href="#zarr-stores" title="Link to this heading"></a></h2>
<p>One solution to the problems NetCDF presents in terms of cloud access issues, would be to migrate
data to a more cloud-friendly format and upload this new format to a public cloud platform like
Amazon S3 or GCP. These use an Object Store architecture in place of a traditional file system.
In object storage, items are collected in a flat hierarchy of buckets, with bytes read and written
within the buckets by http calls. There are several cloud-optimised file formats in development,
with many organisations starting to implement new storages in these formats and enabling cloud access.</p>
<p>Both Cloud Optimised GeoTIFFs (COG) and Zarr Stores break up existing NetCDF data into chunks which
enable HTTP requests for efficient dataset slicing and extraction of only the required data chunks.
Kerchunk originated as a direct alternative to Zarr with many similarities.</p>
<img alt="Diagram for accessing Zarr store data which has been created from a source." src="_images/ZarrDiagram.png" />
<p>Zarr is an open-source specification format for storing N-dimensional arrays that may be
chunked and compressed. Chunks are stored in separate compressed files within a
Zarr (object), along with separated metadata files (Zarray and Zattrs) as shown in Figure, which
allows selection and usage of only specific parts of the data. This is useful for large datasets with
multiple variables as only a handful of chunk files need to be accessed for a typical time-series
slice of multiple variables, whereas doing the same with NetCDF would involve accessing many if
not all the files and require downloading the full dataset or access to JASMIN.</p>
<p>The JSON-style metadata is stored alongside the binary chunk data in the bucket. Each chunk
is named using the index position within the N-dimensional chunking regime of the Zarr data
and is stored as an independent object, hence parallel reads of different Zarr chunks is
supported. Data can be rechunked on conversion to Zarr to suit operational needs and typical use-cases.</p>
</section>
<section id="climate-forecast-aggregations-cfa">
<h2>3. Climate Forecast Aggregations (CFA)<a class="headerlink" href="#climate-forecast-aggregations-cfa" title="Link to this heading"></a></h2>
<p>CFA parameters are now included in the CF conventions (as of CF version 1.12),
and define how so-called <code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">variables</span></code> should be defined within a CFA-netCDF file. A
CFA-netCDF file acts as a reference file to a set of Fragment files (which may be netCDF or other formats),
and an appropriate application reader (like cfapyx) is able to read and interpret the aggregated data into
the proper set of variables and dimensions that cover the extent of the set of Fragment files. Accessing a
subset of the data is then made more efficient as the application reader can fetch only the portions of the
array required by the user for any particular computation.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="usage.html" class="btn btn-neutral float-left" title="CEDA DataPoint - Basic Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="objects.html" class="btn btn-neutral float-right" title="DataPoint Objects" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2024, Centre of Environmental Data Analysis Developers,Scientific and Technical Facilities Council (STFC),UK Research and Innovation (UKRI). BSD 2-Clause License. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>